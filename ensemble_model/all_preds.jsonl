{"instance_id": "astropy__astropy-14995", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..bfd6f06e82 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -520,10 +520,13 @@ class NDArithmeticMixin:\n         elif self.mask is None and operand is not None:\n             # Make a copy so there is no reference in the result.\n             return deepcopy(operand.mask)\n         elif operand is None:\n             return deepcopy(self.mask)\n+        elif operand is not None and operand.mask is None:\n+            # If operand has no mask but self does, return a copy of self.mask\n+            return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n             return handle_mask(self.mask, operand.mask, **kwds)\n \n     def _arithmetic_wcs(self, operation, operand, compare_wcs, **kwds):\n"}
{"instance_id": "django__django-11119", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/template/engine.py b/django/template/engine.py\nindex dfaa67ba12..ff9ce58d59 100644\n--- a/django/template/engine.py\n+++ b/django/template/engine.py\n@@ -158,11 +158,11 @@ class Engine:\n         # Django < 1.8 accepted a Context in `context` even though that's\n         # unintended. Preserve this ability but don't rewrap `context`.\n         if isinstance(context, Context):\n             return t.render(context)\n         else:\n-            return t.render(Context(context))\n+            return t.render(Context(context, autoescape=self.autoescape))\n \n     def select_template(self, template_name_list):\n         \"\"\"\n         Given a list of template names, return the first that can be loaded.\n         \"\"\"\n"}
{"instance_id": "django__django-11964", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 0a5e5ff673..0d4019637a 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -429,18 +429,18 @@ class Model(metaclass=ModelBase):\n             # is *not* consumed. We rely on this, so don't change the order\n             # without changing the logic.\n             for val, field in zip(args, fields_iter):\n                 if val is _DEFERRED:\n                     continue\n-                _setattr(self, field.attname, val)\n+                _setattr(self, field.attname, field.to_python(val))\n         else:\n             # Slower, kwargs-ready version.\n             fields_iter = iter(opts.fields)\n             for val, field in zip(args, fields_iter):\n                 if val is _DEFERRED:\n                     continue\n-                _setattr(self, field.attname, val)\n+                _setattr(self, field.attname, field.to_python(val))\n                 kwargs.pop(field.name, None)\n \n         # Now we're left with the unprocessed fields that *must* come from\n         # keywords, or default.\n \n@@ -480,21 +480,25 @@ class Model(metaclass=ModelBase):\n                 # checked) by the RelatedObjectDescriptor.\n                 if rel_obj is not _DEFERRED:\n                     _setattr(self, field.name, rel_obj)\n             else:\n                 if val is not _DEFERRED:\n-                    _setattr(self, field.attname, val)\n+                    _setattr(self, field.attname, field.to_python(val))\n \n         if kwargs:\n             property_names = opts._property_names\n             for prop in tuple(kwargs):\n                 try:\n                     # Any remaining kwargs must correspond to properties or\n                     # virtual fields.\n                     if prop in property_names or opts.get_field(prop):\n                         if kwargs[prop] is not _DEFERRED:\n-                            _setattr(self, prop, kwargs[prop])\n+                            try:\n+                                field = opts.get_field(prop)\n+                                _setattr(self, prop, field.to_python(kwargs[prop]))\n+                            except (AttributeError, FieldDoesNotExist):\n+                                _setattr(self, prop, kwargs[prop])\n                         del kwargs[prop]\n                 except (AttributeError, FieldDoesNotExist):\n                     pass\n             for kwarg in kwargs:\n                 raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..0c830e1c34 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1,9 +1,10 @@\n import collections.abc\n import copy\n import datetime\n import decimal\n+import enum\n import operator\n import uuid\n import warnings\n from base64 import b64decode, b64encode\n from functools import partialmethod, total_ordering\n@@ -1006,11 +1007,15 @@ class CharField(Field):\n \n     def get_internal_type(self):\n         return \"CharField\"\n \n     def to_python(self, value):\n-        if isinstance(value, str) or value is None:\n+        if value is None:\n+            return value\n+        if isinstance(value, enum.Enum):\n+            return value.value\n+        if isinstance(value, str):\n             return value\n         return str(value)\n \n     def get_prep_value(self, value):\n         value = super().get_prep_value(value)\n@@ -1767,10 +1772,12 @@ class IntegerField(Field):\n         return \"IntegerField\"\n \n     def to_python(self, value):\n         if value is None:\n             return value\n+        if isinstance(value, enum.Enum):\n+            return value.value\n         try:\n             return int(value)\n         except (TypeError, ValueError):\n             raise exceptions.ValidationError(\n                 self.error_messages['invalid'],\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..2422bd63a9 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -134,11 +134,12 @@ class DeferredAttribute:\n             val = self._check_parent_chain(instance)\n             if val is None:\n                 instance.refresh_from_db(fields=[field_name])\n                 val = getattr(instance, field_name)\n             data[field_name] = val\n-        return data[field_name]\n+        # Apply to_python to handle enum values\n+        return self.field.to_python(data[field_name])\n \n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n         loaded in the instance. This can be done if the to-be fetched\n"}
{"instance_id": "django__django-11999", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex ee45bb941e..36ad0b2190 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -761,12 +761,14 @@ class Field(RegisterLookupMixin):\n             # if you have a classmethod and a field with the same name, then\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\n-            setattr(cls, 'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self))\n+            method_name = 'get_%s_display' % self.name\n+            if not hasattr(cls, method_name):\n+                setattr(cls, method_name,\n+                        partialmethod(cls._get_FIELD_display, field=self))\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n         Return a dict that when passed as kwargs to self.model.filter(), would\n         yield all instances having the same value for this field as obj has.\n"}
{"instance_id": "django__django-12262", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/template/library.py b/django/template/library.py\nindex 20bc86dac8..9f392e5ca3 100644\n--- a/django/template/library.py\n+++ b/django/template/library.py\n@@ -249,30 +249,28 @@ def parse_bits(parser, bits, params, varargs, varkw, defaults,\n                 \"'%s' is decorated with takes_context=True so it must \"\n                 \"have a first argument of 'context'\" % name)\n     args = []\n     kwargs = {}\n     unhandled_params = list(params)\n-    unhandled_kwargs = [\n-        kwarg for kwarg in kwonly\n-        if not kwonly_defaults or kwarg not in kwonly_defaults\n-    ]\n+    # Include all keyword-only arguments, regardless of whether they have default values or not\n+    unhandled_kwargs = list(kwonly)\n     for bit in bits:\n         # First we try to extract a potential kwarg from the bit\n         kwarg = token_kwargs([bit], parser)\n         if kwarg:\n             # The kwarg was successfully extracted\n             param, value = kwarg.popitem()\n-            if param not in params and param not in unhandled_kwargs and varkw is None:\n-                # An unexpected keyword argument was supplied\n-                raise TemplateSyntaxError(\n-                    \"'%s' received unexpected keyword argument '%s'\" %\n-                    (name, param))\n-            elif param in kwargs:\n+            if param in kwargs:\n                 # The keyword argument has already been supplied once\n                 raise TemplateSyntaxError(\n                     \"'%s' received multiple values for keyword argument '%s'\" %\n                     (name, param))\n+            elif param not in params and param not in unhandled_kwargs and varkw is None:\n+                # An unexpected keyword argument was supplied\n+                raise TemplateSyntaxError(\n+                    \"'%s' received unexpected keyword argument '%s'\" %\n+                    (name, param))\n             else:\n                 # All good, record the keyword argument\n                 kwargs[str(param)] = value\n                 if param in unhandled_params:\n                     # If using the keyword syntax for a positional arg, then\n"}
{"instance_id": "django__django-13089", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/core/cache/backends/db.py b/django/core/cache/backends/db.py\nindex 33c79c5a14..4d67c18b61 100644\n--- a/django/core/cache/backends/db.py\n+++ b/django/core/cache/backends/db.py\n@@ -265,13 +265,15 @@ class DatabaseCache(BaseDatabaseCache):\n             if num > self._max_entries:\n                 cull_num = num // self._cull_frequency\n                 cursor.execute(\n                     connection.ops.cache_key_culling_sql() % table,\n                     [cull_num])\n-                cursor.execute(\"DELETE FROM %s \"\n-                               \"WHERE cache_key < %%s\" % table,\n-                               [cursor.fetchone()[0]])\n+                result = cursor.fetchone()\n+                if result is not None:\n+                    cursor.execute(\"DELETE FROM %s \"\n+                                   \"WHERE cache_key < %%s\" % table,\n+                                   [result[0]])\n \n     def clear(self):\n         db = router.db_for_write(self.cache_model_class)\n         connection = connections[db]\n         table = connection.ops.quote_name(self._table)\n"}
{"instance_id": "django__django-13112", "model_name_or_path": "20250228_epam-ai-run-claude-3-5-sonnet", "model_patch": "diff --git a/django/apps/registry.py b/django/apps/registry.py\nindex 408964a146..9453165b59 100644\n--- a/django/apps/registry.py\n+++ b/django/apps/registry.py\n@@ -149,11 +149,18 @@ class Apps:\n         Import applications and returns an app config for the given label.\n \n         Raise LookupError if no application exists with this label.\n+        The lookup is case-insensitive.\n         \"\"\"\n         self.check_apps_ready()\n+        # First try exact match\n         try:\n             return self.app_configs[app_label]\n         except KeyError:\n+            # Try case-insensitive match\n+            for config_label, app_config in self.app_configs.items():\n+                if config_label.lower() == app_label.lower():\n+                    return app_config\n+            # No match found, provide helpful error message\n             message = \"No installed app with label '%s'.\" % app_label\n             for app_config in self.get_app_configs():\n                 if app_config.name == app_label:\n@@ -188,7 +195,7 @@ class Apps:\n \n         As a shortcut, app_label may be in the form <app_label>.<model_name>.\n \n-        model_name is case-insensitive.\n+        Both app_label and model_name are case-insensitive.\n \n         Raise LookupError if no application exists with this label, or no\n         model exists with this name in the application. Raise ValueError if\n@@ -202,12 +209,21 @@ class Apps:\n         if model_name is None:\n             app_label, model_name = app_label.split('.')\n \n-        app_config = self.get_app_config(app_label)\n-\n-        if not require_ready and app_config.models is None:\n-            app_config.import_models()\n-\n-        return app_config.get_model(model_name, require_ready=require_ready)\n+        # Try exact match first\n+        try:\n+            app_config = self.get_app_config(app_label)\n+            if not require_ready and app_config.models is None:\n+                app_config.import_models()\n+            return app_config.get_model(model_name, require_ready=require_ready)\n+        except LookupError:\n+            # Try case-insensitive match\n+            app_label_lower = app_label.lower()\n+            for config in self.app_configs.values():\n+                if config.label.lower() == app_label_lower:\n+                    if not require_ready and config.models is None:\n+                        config.import_models()\n+                    return config.get_model(model_name, require_ready=require_ready)\n+            raise\n \n     def register_model(self, app_label, model):\n         # Since this method is called when models are imported, it cannot\n@@ -266,12 +282,24 @@ class Apps:\n \n         It's safe to call this method at import time, even while the registry\n         is being populated.\n+\n+        Both app_label and model_name are case-insensitive.\n         \"\"\"\n+        # Try exact match first\n         model = self.all_models[app_label].get(model_name.lower())\n-        if model is None:\n-            raise LookupError(\n-                \"Model '%s.%s' not registered.\" % (app_label, model_name))\n-        return model\n+        if model is not None:\n+            return model\n+\n+        # Try case-insensitive app_label match\n+        app_label_lower = app_label.lower()\n+        for reg_app_label, models in self.all_models.items():\n+            if reg_app_label.lower() == app_label_lower:\n+                model = models.get(model_name.lower())\n+                if model is not None:\n+                    return model\n+\n+        raise LookupError(\n+            \"Model '%s.%s' not registered.\" % (app_label, model_name))\n \n     @functools.lru_cache(maxsize=None)\n     def get_swappable_settings_name(self, to_string):\n"}
{"instance_id": "django__django-13406", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex b48d0df9c0..f075d13e83 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -209,10 +209,13 @@ class QuerySet:\n         return self._query\n \n     @query.setter\n     def query(self, value):\n         self._query = value\n+        # If the query has values_select set, ensure the correct iterable class is used\n+        if value.values_select:\n+            self._iterable_class = ValuesIterable\n \n     def as_manager(cls):\n         # Address the circular dependency between `Queryset` and `Manager`.\n         from django.db.models.manager import Manager\n         manager = Manager.from_queryset(cls)()\n@@ -256,10 +259,16 @@ class QuerySet:\n                 \"Pickled queryset instance's Django version is not specified.\",\n                 RuntimeWarning,\n                 stacklevel=2,\n             )\n         self.__dict__.update(state)\n+        \n+        # If the query was pickled from a values() or values_list() queryset,\n+        # ensure the correct iterable class is used\n+        if hasattr(self, '_query') and self._query.values_select:\n+            if not hasattr(self, '_iterable_class') or self._iterable_class == ModelIterable:\n+                self._iterable_class = ValuesIterable\n \n     def __repr__(self):\n         data = list(self[:REPR_OUTPUT_SIZE + 1])\n         if len(data) > REPR_OUTPUT_SIZE:\n             data[-1] = \"...(remaining elements truncated)...\"\n"}
{"instance_id": "django__django-14122", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..5a8f7544e5 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -123,15 +123,17 @@ class SQLCompiler:\n             if expr in ref_sources:\n                 continue\n             cols = expr.get_group_by_cols()\n             for col in cols:\n                 expressions.append(col)\n-        for expr, (sql, params, is_ref) in order_by:\n-            # Skip References to the select clause, as all expressions in the\n-            # select clause are already part of the group by.\n-            if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n+        # Skip adding fields from order_by to the GROUP BY clause if self._meta_ordering is not None\n+        if not self._meta_ordering:\n+            for expr, (sql, params, is_ref) in order_by:\n+                # Skip References to the select clause, as all expressions in the\n+                # select clause are already part of the group by.\n+                if not is_ref:\n+                    expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\n         result = []\n         seen = set()\n"}
{"instance_id": "django__django-14238", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..dff37462b3 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2522,11 +2522,15 @@ class AutoFieldMeta(type):\n \n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, sc) for sc in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n \n     def get_internal_type(self):\n"}
{"instance_id": "django__django-14539", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/utils/html.py b/django/utils/html.py\nindex 3bc02b8dd3..69010a0521 100644\n--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -281,12 +281,16 @@ def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):\n             # as encoded entities contain ';'). Unescape entities to avoid\n             # breaking them by removing ';'.\n             middle_unescaped = html.unescape(middle)\n             stripped = middle_unescaped.rstrip(TRAILING_PUNCTUATION_CHARS)\n             if middle_unescaped != stripped:\n-                trail = middle[len(stripped):] + trail\n-                middle = middle[:len(stripped) - len(middle_unescaped)]\n+                # Calculate how many characters were stripped from the end\n+                trailing_chars = len(middle_unescaped) - len(stripped)\n+                \n+                # The last 'trailing_chars' characters of the original string should be moved to trail\n+                trail = middle[-trailing_chars:] + trail\n+                middle = middle[:-trailing_chars]\n                 trimmed_something = True\n         return lead, middle, trail\n \n     def is_email_simple(value):\n         \"\"\"Return True if value looks like an email address.\"\"\"\n"}
{"instance_id": "django__django-15268", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex c120f5d32d..8fcfa4c53a 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -525,10 +525,18 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n         return \"Alter %s for %s (%s constraint(s))\" % (self.option_name, self.name, len(self.option_value or ''))\n \n     @property\n     def migration_name_fragment(self):\n         return 'alter_%s_%s' % (self.name_lower, self.option_name)\n+        \n+    def reduce(self, operation, app_label):\n+        if (isinstance(operation, self.__class__) and  # Same operation type\n+                self.name_lower == operation.name_lower and  # Same model\n+                not self.option_value and  # First operation sets option to empty set\n+                operation.option_value):  # Second operation sets option to non-empty set\n+            return [operation]  # Keep only the second operation\n+        return super().reduce(operation, app_label)\n \n \n class AlterUniqueTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of unique_together to the target one.\n"}
{"instance_id": "django__django-15987", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/core/management/commands/loaddata.py b/django/core/management/commands/loaddata.py\nindex ac97f13161..9c43e02410 100644\n--- a/django/core/management/commands/loaddata.py\n+++ b/django/core/management/commands/loaddata.py\n@@ -360,16 +360,19 @@ class Command(BaseCommand):\n         application, if it exists, the directories in FIXTURE_DIRS, and the\n         current directory.\n         \"\"\"\n         dirs = []\n         fixture_dirs = settings.FIXTURE_DIRS\n-        if len(fixture_dirs) != len(set(fixture_dirs)):\n+        # Convert all paths to their absolute, normalized form\n+        normalized_dirs = [os.path.realpath(str(d)) for d in fixture_dirs]\n+        if len(normalized_dirs) != len(set(normalized_dirs)):\n             raise ImproperlyConfigured(\"settings.FIXTURE_DIRS contains duplicates.\")\n         for app_config in apps.get_app_configs():\n             app_label = app_config.label\n             app_dir = os.path.join(app_config.path, \"fixtures\")\n-            if app_dir in fixture_dirs:\n+            app_dir_real = os.path.realpath(app_dir)\n+            if app_dir_real in normalized_dirs:\n                 raise ImproperlyConfigured(\n                     \"'%s' is a default fixture directory for the '%s' app \"\n                     \"and cannot be listed in settings.FIXTURE_DIRS.\"\n                     % (app_dir, app_label)\n                 )\n"}
{"instance_id": "django__django-16136", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/views/generic/base.py b/django/views/generic/base.py\nindex db1842e3e5..6ae8177f3f 100644\n--- a/django/views/generic/base.py\n+++ b/django/views/generic/base.py\n@@ -146,11 +146,18 @@ class View:\n             \"Method Not Allowed (%s): %s\",\n             request.method,\n             request.path,\n             extra={\"status_code\": 405, \"request\": request},\n         )\n-        return HttpResponseNotAllowed(self._allowed_methods())\n+        response = HttpResponseNotAllowed(self._allowed_methods())\n+        \n+        if self.view_is_async:\n+            async def func():\n+                return response\n+            return func()\n+        else:\n+            return response\n \n     def options(self, request, *args, **kwargs):\n         \"\"\"Handle responding to requests for the OPTIONS HTTP verb.\"\"\"\n         response = HttpResponse()\n         response.headers[\"Allow\"] = \", \".join(self._allowed_methods())\n"}
{"instance_id": "django__django-16801", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/db/models/fields/files.py b/django/db/models/fields/files.py\nindex 7f8eb128e1..22113d2caa 100644\n--- a/django/db/models/fields/files.py\n+++ b/django/db/models/fields/files.py\n@@ -439,11 +439,12 @@ class ImageField(FileField):\n         super().contribute_to_class(cls, name, **kwargs)\n         # Attach update_dimension_fields so that dimension fields declared\n         # after their corresponding image field don't stay cleared by\n         # Model.__init__, see bug #11196.\n         # Only run post-initialization dimension update on non-abstract models\n-        if not cls._meta.abstract:\n+        # and only if width_field or height_field are set\n+        if not cls._meta.abstract and (self.width_field or self.height_field):\n             signals.post_init.connect(self.update_dimension_fields, sender=cls)\n \n     def update_dimension_fields(self, instance, force=False, *args, **kwargs):\n         \"\"\"\n         Update field's width and height fields, if defined.\n"}
{"instance_id": "matplotlib__matplotlib-20488", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/lib/matplotlib/image.py b/lib/matplotlib/image.py\nindex 95bb42d75c..134343ec40 100644\n--- a/lib/matplotlib/image.py\n+++ b/lib/matplotlib/image.py\n@@ -531,11 +531,11 @@ class _ImageBase(martist.Artist, cm.ScalarMappable):\n                 resampled_masked = np.ma.masked_array(A_resampled, out_mask)\n                 # we have re-set the vmin/vmax to account for small errors\n                 # that may have moved input values in/out of range\n                 s_vmin, s_vmax = vrange\n                 if isinstance(self.norm, mcolors.LogNorm):\n-                    if s_vmin < 0:\n+                    if s_vmin <= 0:\n                         s_vmin = max(s_vmin, np.finfo(scaled_dtype).eps)\n                 with cbook._setattr_cm(self.norm,\n                                        vmin=s_vmin,\n                                        vmax=s_vmax,\n                                        ):\n"}
{"instance_id": "matplotlib__matplotlib-23314", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/lib/mpl_toolkits/mplot3d/axes3d.py b/lib/mpl_toolkits/mplot3d/axes3d.py\nindex 9db44b7994..83fef6b5a7 100644\n--- a/lib/mpl_toolkits/mplot3d/axes3d.py\n+++ b/lib/mpl_toolkits/mplot3d/axes3d.py\n@@ -385,10 +385,14 @@ class Axes3D(Axes):\n         pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)\n         self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n \n     @martist.allow_rasterization\n     def draw(self, renderer):\n+        # Return early if the Axes isn't visible\n+        if not self.get_visible():\n+            return\n+            \n         self._unstale_viewLim()\n \n         # draw the background patch\n         self.patch.draw(renderer)\n         self._frameon = False\n"}
{"instance_id": "matplotlib__matplotlib-25287", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex c0e706e2b3..0920063693 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -2253,11 +2253,11 @@ class XAxis(Axis):\n             x=1, y=0,\n             verticalalignment='top', horizontalalignment='right',\n             transform=mtransforms.blended_transform_factory(\n                 self.axes.transAxes, mtransforms.IdentityTransform()),\n             fontsize=mpl.rcParams['xtick.labelsize'],\n-            color=mpl.rcParams['xtick.color'],\n+            color=mpl.rcParams['xtick.color'] if mpl.rcParams['xtick.labelcolor']=='inherit' else mpl.rcParams['xtick.labelcolor'],\n         )\n         self.offset_text_position = 'bottom'\n \n     def contains(self, mouseevent):\n         \"\"\"Test whether the mouse event occurred in the x-axis.\"\"\"\n@@ -2513,11 +2513,11 @@ class YAxis(Axis):\n             x=0, y=0.5,\n             verticalalignment='baseline', horizontalalignment='left',\n             transform=mtransforms.blended_transform_factory(\n                 self.axes.transAxes, mtransforms.IdentityTransform()),\n             fontsize=mpl.rcParams['ytick.labelsize'],\n-            color=mpl.rcParams['ytick.color'],\n+            color=mpl.rcParams['ytick.color'] if mpl.rcParams['ytick.labelcolor']=='inherit' else mpl.rcParams['ytick.labelcolor'],\n         )\n         self.offset_text_position = 'left'\n \n     def contains(self, mouseevent):\n         # docstring inherited\n"}
{"instance_id": "matplotlib__matplotlib-26342", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py\nindex 3f84250b64..61af2822b8 100644\n--- a/lib/matplotlib/contour.py\n+++ b/lib/matplotlib/contour.py\n@@ -983,10 +983,24 @@ class ContourSet(ContourLabeler, mcoll.Collection):\n             self._transform = self.axes.transData\n         elif (not isinstance(self._transform, mtransforms.Transform)\n               and hasattr(self._transform, '_as_mpl_transform')):\n             self._transform = self._transform._as_mpl_transform(self.axes)\n         return self._transform\n+        \n+    def set_paths(self, paths):\n+        \"\"\"\n+        Set the paths of this ContourSet.\n+        \n+        Parameters\n+        ----------\n+        paths : list of Path\n+            The new paths for this ContourSet.\n+        \"\"\"\n+        self._paths = paths\n+        if hasattr(self, \"_old_style_split_collections\"):\n+            del self._old_style_split_collections  # Invalidate them.\n+        self.stale = True\n \n     def __getstate__(self):\n         state = self.__dict__.copy()\n         # the C object _contour_generator cannot currently be pickled. This\n         # isn't a big issue as it is not actually used once the contour has\n"}
{"instance_id": "pytest-dev__pytest-5809", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/src/_pytest/pastebin.py b/src/_pytest/pastebin.py\nindex 41576a615..79b0d9d40 100644\n--- a/src/_pytest/pastebin.py\n+++ b/src/_pytest/pastebin.py\n@@ -77,11 +77,11 @@ def create_new_paste(contents):\n         from urllib.request import urlopen\n         from urllib.parse import urlencode\n \n     params = {\n         \"code\": contents,\n-        \"lexer\": \"python3\" if sys.version_info[0] >= 3 else \"python\",\n+        \"lexer\": \"text\",\n         \"expiry\": \"1week\",\n     }\n     url = \"https://bpaste.net\"\n     response = urlopen(url, data=urlencode(params).encode(\"ascii\")).read()\n     m = re.search(r'href=\"/raw/(\\w+)\"', response.decode(\"utf-8\"))\ndiff --git a/testing/test_pastebin.py b/testing/test_pastebin.py\nindex bac8f9802..aac0b651e 100644\n--- a/testing/test_pastebin.py\n+++ b/testing/test_pastebin.py\n@@ -124,10 +124,9 @@ class TestPaste(object):\n         result = pastebin.create_new_paste(b\"full-paste-contents\")\n         assert result == \"https://bpaste.net/show/3c0c6750bd\"\n         assert len(mocked_urlopen) == 1\n         url, data = mocked_urlopen[0]\n         assert type(data) is bytes\n-        lexer = \"python3\" if sys.version_info[0] >= 3 else \"python\"\n         assert url == \"https://bpaste.net\"\n-        assert \"lexer=%s\" % lexer in data.decode()\n+        assert \"lexer=text\" in data.decode()\n         assert \"code=full-paste-contents\" in data.decode()\n         assert \"expiry=1week\" in data.decode()\n"}
{"instance_id": "scikit-learn__scikit-learn-11578", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/sklearn/linear_model/logistic.py b/sklearn/linear_model/logistic.py\nindex e4ea696ce..56896769e 100644\n--- a/sklearn/linear_model/logistic.py\n+++ b/sklearn/linear_model/logistic.py\n@@ -920,11 +920,22 @@ def _log_reg_scoring_path(X, y, train, test, pos_class=None, Cs=10,\n         tol=tol, verbose=verbose, dual=dual, penalty=penalty,\n         intercept_scaling=intercept_scaling, random_state=random_state,\n         check_input=False, max_squared_sum=max_squared_sum,\n         sample_weight=sample_weight)\n \n-    log_reg = LogisticRegression(fit_intercept=fit_intercept)\n+    log_reg = LogisticRegression(\n+        fit_intercept=fit_intercept,\n+        multi_class=multi_class,\n+        solver=solver,\n+        penalty=penalty,\n+        dual=dual,\n+        tol=tol,\n+        max_iter=max_iter,\n+        class_weight=class_weight,\n+        random_state=random_state,\n+        intercept_scaling=intercept_scaling\n+    )\n \n     # The score method of Logistic Regression has a classes_ attribute.\n     if multi_class == 'ovr':\n         log_reg.classes_ = np.array([-1, 1])\n     elif multi_class == 'multinomial':\n@@ -1162,11 +1173,11 @@ class LogisticRegression(BaseEstimator, LinearClassifierMixin,\n         Machine Learning 85(1-2):41-75.\n         http://www.csie.ntu.edu.tw/~cjlin/papers/maxent_dual.pdf\n     \"\"\"\n \n     def __init__(self, penalty='l2', dual=False, tol=1e-4, C=1.0,\n-                 fit_intercept=True, intercept_scaling=1, class_weight=None,\n+                 fit_intercept=True, intercept_scaling=1.0, class_weight=None,\n                  random_state=None, solver='liblinear', max_iter=100,\n                  multi_class='ovr', verbose=0, warm_start=False, n_jobs=1):\n \n         self.penalty = penalty\n         self.dual = dual\n"}
{"instance_id": "scikit-learn__scikit-learn-13779", "model_name_or_path": "20250206_agentscope", "model_patch": "diff --git a/sklearn/ensemble/voting.py b/sklearn/ensemble/voting.py\nindex 7afa7180c..13accdcec 100644\n--- a/sklearn/ensemble/voting.py\n+++ b/sklearn/ensemble/voting.py\n@@ -78,7 +78,7 @@ class _BaseVoting(_BaseComposition, TransformerMixin):\n \n         if sample_weight is not None:\n             for name, step in self.estimators:\n-                if not has_fit_parameter(step, 'sample_weight'):\n+                if step is not None and not has_fit_parameter(step, 'sample_weight'):\n                     raise ValueError('Underlying estimator \\'%s\\' does not'\n                                      ' support sample weights.' % name)\n \n"}
{"instance_id": "scikit-learn__scikit-learn-14894", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py\nindex 64cebe837..67e638486 100644\n--- a/sklearn/svm/base.py\n+++ b/sklearn/svm/base.py\n@@ -284,16 +284,20 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):\n             n_class = len(self.classes_) - 1\n         else:  # regression\n             n_class = 1\n         n_SV = self.support_vectors_.shape[0]\n \n-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n-                                     dual_coef_indices.size / n_class)\n-        self.dual_coef_ = sp.csr_matrix(\n-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n-            (n_class, n_SV))\n+        if n_SV == 0:\n+            # Handle the case where there are no support vectors\n+            self.dual_coef_ = sp.csr_matrix((n_class, n_SV))\n+        else:\n+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)\n+            dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,\n+                                        dual_coef_indices.size / n_class)\n+            self.dual_coef_ = sp.csr_matrix(\n+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),\n+                (n_class, n_SV))\n \n     def predict(self, X):\n         \"\"\"Perform regression on samples in X.\n \n         For an one-class model, +1 (inlier) or -1 (outlier) is returned.\n"}
{"instance_id": "sphinx-doc__sphinx-10466", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git b/sphinx/builders/gettext.py a/sphinx/builders/gettext.py\nindex 4cebeeb80..e8bc547b7 100644\n--- b/sphinx/builders/gettext.py\n+++ a/sphinx/builders/gettext.py\n@@ -30,17 +30,12 @@ logger = logging.getLogger(__name__)\n \n class Message:\n     \"\"\"An entry of translatable message.\"\"\"\n     def __init__(self, text: str, locations: List[Tuple[str, int]], uuids: List[str]):\n         self.text = text\n-        self.locations = self.uniqueLocation(locations)\n+        self.locations = locations\n         self.uuids = uuids\n-        \n-    def uniqueLocation(self, locations: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n-        \"\"\"Remove duplicate locations from the locations list.\"\"\"\n-        loc_set = set(locations)\n-        return list(loc_set)\n \n \n class Catalog:\n     \"\"\"Catalog of translatable messages.\"\"\"\n \n"}
{"instance_id": "sphinx-doc__sphinx-9367", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git b/sphinx/pycode/ast.py a/sphinx/pycode/ast.py\nindex 2b4f0d434..f541ec0a9 100644\n--- b/sphinx/pycode/ast.py\n+++ a/sphinx/pycode/ast.py\n@@ -211,16 +211,14 @@ class _UnparseVisitor(ast.NodeVisitor):\n \n     def visit_UnaryOp(self, node: ast.UnaryOp) -> str:\n         return \"%s %s\" % (self.visit(node.op), self.visit(node.operand))\n \n     def visit_Tuple(self, node: ast.Tuple) -> str:\n-        if not node.elts:\n-            return \"()\"\n-        elif len(node.elts) == 1:\n-            return \"(\" + self.visit(node.elts[0]) + \",)\"\n-        else:\n+        if node.elts:\n             return \"(\" + \", \".join(self.visit(e) for e in node.elts) + \")\"\n+        else:\n+            return \"()\"\n \n     if sys.version_info < (3, 8):\n         # these ast nodes were deprecated in python 3.8\n         def visit_Bytes(self, node: ast.Bytes) -> str:\n             return repr(node.s)\n"}
{"instance_id": "sphinx-doc__sphinx-9711", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git b/sphinx/extension.py a/sphinx/extension.py\nindex cc7315a5a..7ec6c8518 100644\n--- b/sphinx/extension.py\n+++ a/sphinx/extension.py\n@@ -8,12 +8,10 @@\n     :license: BSD, see LICENSE for details.\n \"\"\"\n \n from typing import TYPE_CHECKING, Any, Dict\n \n-from packaging.version import parse as parse_version\n-\n from sphinx.config import Config\n from sphinx.errors import VersionRequirementError\n from sphinx.locale import __\n from sphinx.util import logging\n \n@@ -51,11 +49,11 @@ def verify_needs_extensions(app: \"Sphinx\", config: Config) -> None:\n         if extension is None:\n             logger.warning(__('The %s extension is required by needs_extensions settings, '\n                               'but it is not loaded.'), extname)\n             continue\n \n-        if extension.version == 'unknown version' or parse_version(reqversion) > parse_version(extension.version):\n+        if extension.version == 'unknown version' or reqversion > extension.version:\n             raise VersionRequirementError(__('This project needs the extension %s at least in '\n                                              'version %s and therefore cannot be built with '\n                                              'the loaded version (%s).') %\n                                           (extname, reqversion, extension.version))\n \n"}
{"instance_id": "sympy__sympy-20801", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/sympy/core/numbers.py b/sympy/core/numbers.py\nindex 79f6a7d165..a2557d5251 100644\n--- a/sympy/core/numbers.py\n+++ b/sympy/core/numbers.py\n@@ -1384,14 +1384,14 @@ def __eq__(self, other):\n         from sympy.logic.boolalg import Boolean\n         try:\n             other = _sympify(other)\n         except SympifyError:\n             return NotImplemented\n-        if not self:\n-            return not other\n         if isinstance(other, Boolean):\n             return False\n+        if not self:\n+            return not other\n         if other.is_NumberSymbol:\n             if other.is_irrational:\n                 return False\n             return other.__eq__(self)\n         if other.is_Float:\n"}
{"instance_id": "sympy__sympy-22914", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex 3a72ab606c..e82445fcf5 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -435,10 +435,16 @@ def _print_Not(self, expr):\n     def _print_Indexed(self, expr):\n         base = expr.args[0]\n         index = expr.args[1:]\n         return \"{}[{}]\".format(str(base), \", \".join([self._print(ind) for ind in index]))\n \n+    def _print_Min(self, expr):\n+        return \"min({})\".format(\", \".join(self._print(arg) for arg in expr.args))\n+\n+    def _print_Max(self, expr):\n+        return \"max({})\".format(\", \".join(self._print(arg) for arg in expr.args))\n+\n     def _print_Pow(self, expr, rational=False):\n         return self._hprint_Pow(expr, rational=rational)\n \n     def _print_Rational(self, expr):\n         return '{}/{}'.format(expr.p, expr.q)\n"}
{"instance_id": "sympy__sympy-23262", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/sympy/utilities/lambdify.py b/sympy/utilities/lambdify.py\nindex da67263b19..1bbf88b0d3 100644\n--- a/sympy/utilities/lambdify.py\n+++ b/sympy/utilities/lambdify.py\n@@ -957,10 +957,13 @@ def _recursive_to_string(doprint, arg):\n     elif iterable(arg):\n         if isinstance(arg, list):\n             left, right = \"[]\"\n         elif isinstance(arg, tuple):\n             left, right = \"()\"\n+            # Special case for single-element tuples\n+            if len(arg) == 1:\n+                return left + _recursive_to_string(doprint, arg[0]) + \",\" + right\n         else:\n             raise NotImplementedError(\"unhandled type: %s, %s\" % (type(arg), arg))\n         return left +', '.join(_recursive_to_string(doprint, e) for e in arg) + right\n     elif isinstance(arg, str):\n         return arg\n"}
{"instance_id": "django__django-13925", "model_name_or_path": "20250316_augment_agent_v0", "model_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 4038859cfa..35cc2feacf 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1298,11 +1298,12 @@ class Model(metaclass=ModelBase):\n     @classmethod\n     def _check_default_pk(cls):\n         if (\n             cls._meta.pk.auto_created and\n             not settings.is_overridden('DEFAULT_AUTO_FIELD') and\n-            not cls._meta.app_config._is_default_auto_field_overridden\n+            not cls._meta.app_config._is_default_auto_field_overridden and\n+            not (cls._meta.pk.remote_field and cls._meta.pk.remote_field.parent_link)\n         ):\n             return [\n                 checks.Warning(\n                     f\"Auto-created primary key used when not defining a \"\n                     f\"primary key type, by default \"\n"}
